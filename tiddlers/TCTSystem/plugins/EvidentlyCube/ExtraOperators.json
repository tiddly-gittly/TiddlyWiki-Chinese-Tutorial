{"tiddlers":{"$:/plugins/EvidentlyCube/ExtraOperators/common.js":{"title":"$:/plugins/EvidentlyCube/ExtraOperators/common.js","text":"/*\\\ntitle: $:/plugins/EvidentlyCube/ExtraOperators/common.js\ntype: application/javascript\nmodule-type: filteroperator\n\nSmart sorting of search results\n\n\\*/\n(function(){\n\n\t/*jslint node: true, browser: true */\n\t/*global $tw: false */\n\t\"use strict\";\n\n\texports.TEXT_ONLY_REGEXPS = [\n\t\t[/\\\\define\\s+([^(\\s]+)\\([^\\)]*\\)(\\r?\\n(\\s|\\S)*?\\end|.+?(\\r?\\n|$))/ig, ''], // Macro definitions\n\t\t[/^\\s*\\\\(?:\\s|\\S)+?($|\\n([^\\\\\\r\\n]))/ig, '$1'], // Arbitrary pragmas at the start\n\t\t[/\\[img[^\\]]*\\]\\]/ig, ''], // Images\n\t\t[/^@@.*?(\\r?\\n|$)/igm, ''], // Styles\n\t\t[/^\\$\\$\\$.*?(\\r?\\n|$)/igm, ''], // Typed block\n\t\t[/\\{\\{\\{[^\\}]*\\}\\}\\}/ig, ''], // Filter invocations\n\t\t[/\\{\\{[^\\}]*\\}\\}/ig, ''], // Transclusions\n\t\t[/\\[\\[([^\\]]+(?=\\|))?\\|?[^\\]]+\\]\\]/ig, '$1'], // Links\n\t\t[/<<[^>]*>>/ig, ''], // Macro invocations\n\t\t[/<\\/?[^>]*>/ig, ''], // HTML Tags\n\t\t[/''|`|__|\\/\\/|^!+\\s+|~~/mg, '']\n\t];\n\n\texports.SIMPLIFY_REGEXP = /[^ a-z0-9_-]/ig;\n\n\texports.getRegexpsForPhrase = function(phrase) {\n\t\tconst escapedPhrase = $tw.utils.escapeRegExp(phrase);\n\n\t\treturn [\n\t\t\tnew RegExp(`^${escapedPhrase}\\\\b`, 'gi'),\n\t\t\tnew RegExp(`^${escapedPhrase}`, 'gi'),\n\t\t\tnew RegExp(`\\\\b${escapedPhrase}\\\\b`, 'gi'),\n\t\t\tnew RegExp(`\\\\b${escapedPhrase}`, 'gi'),\n\t\t\tnew RegExp(escapedPhrase, 'gi'),\n\t\t];\n\t};\n\n})();\n","type":"application/javascript","module-type":"filteroperator"},"$:/plugins/EvidentlyCube/ExtraOperators/focus-on.js":{"title":"$:/plugins/EvidentlyCube/ExtraOperators/focus-on.js","text":"/*\\\ntitle: $:/plugins/EvidentlyCube/ExtraOperators/focus-on.js\ntype: application/javascript\nmodule-type: filteroperator\n\nExtract part of text focusing on the first occurrence\n\n\\*/\n(function (require) {\n\t/*jslint node: true, browser: true */\n\t/*global $tw: false */\n\t\"use strict\";\n\n\texports['focus-on'] = function (source, operator, opts) {\n\t\tconst operands = operator.operands || [];\n\t\tconst suffixes = (operator.suffixes || []);\n\t\tconst flags = suffixes[0] || [];\n\t\tconst options = {\n\t\t\tmatch: operands[0] || '',\n\t\t\tprefixLength: extractInteger(operands[1], 20),\n\t\t\tfocusLength: extractInteger(operands[2], 128),\n\t\t\tellipsis: extractString(operands[3], '...'),\n\t\t\tisRegexp: flags.includes('regexp'),\n\t\t\tisCaseSensitive: flags.includes('casesensitive'),\n\t\t\thtmlMode: extractHtmlMode(flags),\n\t\t\twiki: opts.wiki,\n\t\t\ttemplate: operator.operands[1] || '<mark>$1</mark>'\n\t\t};\n\n\t\tconst titles = [];\n\n\t\tsource(function (tiddler, title) {\n\t\t\ttitles.push(focusOn(title, options));\n\t\t});\n\n\t\treturn titles;\n\t};\n\n\tfunction focusOn(title, options) {\n\t\tconst matchIndex = getFirstMatchIndex(title, options.match, options);\n\t\tconst startIndex = getStartIndex(title, matchIndex, options);\n\t\tconst endIndex = getEndIndex(title, matchIndex, options);\n\n\t\treturn (startIndex > 0 ? options.ellipsis : '')\n\t\t\t+ title.substring(startIndex, endIndex)\n\t\t\t+ (endIndex < title.length ? options.ellipsis : '');\n\t}\n\n\tfunction getFirstMatchIndex(title, match, options) {\n\t\tif (options.isRegexp) {\n\t\t\ttry {\n\t\t\t\treturn Math.max(0, title.search(new RegExp(match, options.isCaseSensitive ? '' : 'i')));\n\t\t\t} catch (e) {\n\t\t\t\t// Handle invalid regular expressions\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tif (!options.isCaseSensitive) {\n\t\t\ttitle = title.toLocaleLowerCase();\n\t\t\tmatch = match.toLocaleLowerCase();\n\t\t}\n\n\t\treturn Math.max(0, title.indexOf(match));\n\t}\n\n\tfunction getStartIndex(title, matchIndex, options) {\n\t\tconst baseIndex = Math.max(0, matchIndex - options.prefixLength);\n\t\tif (options.htmlMode === 'ignore-html') {\n\t\t\treturn baseIndex;\n\t\t}\n\n\t\tconst openTagIndex = title.indexOf('<', baseIndex);\n\t\tconst closeTagIndex = title.indexOf('>', baseIndex);\n\t\tconst openTagPrevIndex = title.lastIndexOf('<', baseIndex);\n\t\tconst closeTagPrevIndex = title.lastIndexOf('>', baseIndex);\n\n\t\tif (isInsideHtmlTag(openTagPrevIndex, openTagIndex, closeTagPrevIndex, closeTagIndex)) {\n\t\t\treturn options.htmlMode === 'strip-html'\n\t\t\t\t? closeTagIndex + 1\n\t\t\t\t: openTagPrevIndex;\n\t\t}\n\n\t\treturn baseIndex;\n\t}\n\n\tfunction getEndIndex(title, matchIndex, options) {\n\t\tconst baseIndex = Math.min(title.length, matchIndex + options.focusLength);;\n\t\tif (options.htmlMode === 'ignore-html') {\n\t\t\treturn baseIndex;\n\t\t}\n\n\t\tconst openTagIndex = title.indexOf('<', baseIndex);\n\t\tconst closeTagIndex = title.indexOf('>', baseIndex);\n\t\tconst openTagPrevIndex = title.lastIndexOf('<', baseIndex);\n\t\tconst closeTagPrevIndex = title.lastIndexOf('>', baseIndex);\n\n\t\tif (isInsideHtmlTag(openTagPrevIndex, openTagIndex, closeTagPrevIndex, closeTagIndex)) {\n\t\t\treturn options.htmlMode === 'strip-html'\n\t\t\t\t? openTagPrevIndex\n\t\t\t\t: closeTagIndex + 1;\n\t\t}\n\n\t\treturn baseIndex;\n\t}\n\n\tfunction isInsideHtmlTag(leftOpenTagIndex, rightOpenTagIndex, leftCloseTagIndex, rightCloseTagIndex) {\n\t\tif (rightOpenTagIndex !== -1 && rightCloseTagIndex !== -1) {\n\t\t\tif (rightCloseTagIndex < rightOpenTagIndex && leftOpenTagIndex !== -1) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tif (leftOpenTagIndex !== -1 && leftCloseTagIndex !== -1) {\n\t\t\tif (leftOpenTagIndex > leftCloseTagIndex && rightCloseTagIndex !== -1) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\n\tfunction extractHtmlMode(flags) {\n\t\tif (flags.includes('ignore-html')) {\n\t\t\treturn 'ignore-html';\n\t\t} else if (flags.includes('strip-html')) {\n\t\t\treturn 'strip-html';\n\t\t} else {\n\t\t\treturn 'expand-html';\n\t\t}\n\t}\n\n\tfunction extractInteger(value, defaultValue) {\n\t\tif (value === undefined) {\n\t\t\treturn defaultValue;\n\t\t}\n\n\t\tconst intValue = parseInt(value);\n\t\tif (Number.isNaN(intValue)) {\n\t\t\treturn defaultValue;\n\t\t}\n\n\t\treturn Math.max(0, Math.min(9999, intValue));\n\t}\n\n\tfunction extractString(value, defaultValue) {\n\t\tif (value === undefined) {\n\t\t\treturn defaultValue;\n\t\t}\n\n\t\treturn String(value);\n\t}\n})(typeof global !== 'undefined' ? global.testRequire : require);\n","type":"application/javascript","module-type":"filteroperator"},"$:/plugins/EvidentlyCube/ExtraOperators/history":{"title":"$:/plugins/EvidentlyCube/ExtraOperators/history","type":"text/vnd.tiddlywiki","text":"* ''1.1.0'' -- `susearch` now supports `strict` flag which requires all words to match to include in the output.\n* ''1.0.2'' -- `susearch`, `susearch-sort` and `susearch-mark` no longer ignore spaces when matching words (ie. `sand` no longer matches `s and`).\n* ''1.0.1'' -- `focus-on` fixed a bug where last character would not be displayed if the whole text was supposed to be visible\n* ''1.0.0'' -- Initial release"},"$:/plugins/EvidentlyCube/ExtraOperators/icon":{"title":"$:/plugins/EvidentlyCube/ExtraOperators/icon","text":"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","type":"image/png"},"$:/plugins/EvidentlyCube/ExtraOperators/license":{"title":"$:/plugins/EvidentlyCube/ExtraOperators/license","type":"text/vnd.tiddlywiki","text":"This plugin is licensed under the MIT license.\n\nCopyright 2023 Maurycy Zarzycki\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."},"$:/plugins/EvidentlyCube/ExtraOperators/readme":{"title":"$:/plugins/EvidentlyCube/ExtraOperators/readme","type":"text/vnd.tiddlywiki","text":"[[Github|https://github.com/EvidentlyCube/TW5-FilterOperatorslete]]\n\n----\n\n! Features\n\nA collection of awesome filters. The documentation for the filters is available on [[Evidently Cube Plugin Showcase|https://evidentlycube.github.io/TW5-PluginShowcase/#Extra%20Operators]]."},"$:/plugins/EvidentlyCube/ExtraOperators/susearch-mark.js":{"title":"$:/plugins/EvidentlyCube/ExtraOperators/susearch-mark.js","text":"/*\\\ntitle: $:/plugins/EvidentlyCube/ExtraOperators/susearch-mark.js\ntype: application/javascript\nmodule-type: filteroperator\n\nSmart sorting of search results\n\n\\*/\n(function (require) {\n\t/*jslint node: true, browser: true */\n\t/*global $tw: false */\n\t\"use strict\";\n\n\tconst common = require('$:/plugins/EvidentlyCube/ExtraOperators/common.js');\n\n\texports['susearch-mark'] = function (source, operator, opts) {\n\t\tconst query = operator.operand || '';\n\t\tconst suffixes = (operator.suffixes || []);\n\t\tconst optionFlags = suffixes[0] || [];\n\t\tconst options = {\n\t\t\tmode: extractMode(optionFlags),\n\t\t\twiki: opts.wiki,\n\t\t\ttemplate: operator.operands[1] || '<mark>$1</mark>'\n\t\t};\n\n\t\tconst fullRegexp = prepareFullRegexp(query);\n\t\tconst titles = [];\n\n\t\tsource(function (tiddler, title) {\n\t\t\ttitles.push(mark(title, fullRegexp, options));\n\t\t});\n\n\t\treturn titles;\n\t};\n\n\tfunction mark(title, fullRegexp, options) {\n\t\tswitch (options.mode) {\n\t\t\tcase 'default':\n\t\t\t\treturn doFullRegexpReplace(title, fullRegexp, options.template);\n\n\t\t\tcase 'raw-strip':\n\t\t\t\treturn doFullRegexpReplace(rawStrip(title), fullRegexp, options.template);\n\n\t\t\tcase 'wikify-strip':\n\t\t\t\treturn doFullRegexpReplace(\n\t\t\t\t\twikify(title, options.wiki, false).textContent,\n\t\t\t\t\tfullRegexp,\n\t\t\t\t\toptions.template\n\t\t\t\t);\n\n\t\t\tcase 'wikify-safe':\n\t\t\t\treturn wikifySafe(title, fullRegexp, options, false);\n\t\t}\n\t}\n\n\tfunction doFullRegexpReplace(title, fullRegexp, template) {\n\t\treturn fullRegexp\n\t\t\t? title.replace(fullRegexp, template)\n\t\t\t: title;\n\t}\n\n\tfunction prepareFullRegexp(query) {\n\t\tconst sanitizedQuery = query.replace(/\\s+/g, ' ').trim().toLowerCase();\n\t\tconst words = sanitizedQuery.split(' ').filter(word => word);\n\t\tconst simplifiedWords = sanitizedQuery.replace(common.SIMPLIFY_REGEXP, '').split(' ').filter(word => word);\n\n\t\tif (sanitizedQuery === '') {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst regexpPieces = [$tw.utils.escapeRegExp(sanitizedQuery)];\n\t\tregexpPieces.push(...words.map(word => $tw.utils.escapeRegExp(word)));\n\t\tregexpPieces.push(...simplifiedWords.map(word => $tw.utils.escapeRegExp(word)));\n\n\t\treturn new RegExp('(' + regexpPieces.join(\"|\").replace(/ /g, '\\\\s+') + ')', 'gi');\n\t}\n\n\tfunction wikify(text, wiki, isInline) {\n\t\tconst parser = wiki.parseText(\"text/vnd.tiddlywiki\", text, {parseAsInline: isInline });\n\t\tconst container = $tw.fakeDocument.createElement(\"div\");\n\t\tconst widget = wiki.makeWidget(parser, {\n\t\t\tdocument: $tw.fakeDocument,\n\t\t\tparentWidget: $tw.rootWidget\n\t\t});\n\t\twidget.render(container, null);\n\n\t\treturn container;\n\t}\n\n\tfunction rawStrip(field) {\n\t\treturn common.TEXT_ONLY_REGEXPS.reduce((field, [regexp, replace]) => field.replace(regexp, replace), field);\n\t}\n\n\tfunction extractMode(optionFlags) {\n\t\tswitch (optionFlags.join(',')) {\n\t\t\tcase 'raw-strip': return 'raw-strip';\n\t\t\tcase 'wikify-strip': return 'wikify-strip';\n\t\t\tcase 'wikify-safe': return 'wikify-safe';\n\t\t\tdefault: return 'default';\n\t\t}\n\t}\n\n\tfunction wikifySafe(text, fullRegexp, options, isInline) {\n\t\tconst wikifiedText = wikify(text, options.wiki, isInline).innerHTML;\n\t\tconst tokens = [];\n\n\t\tconst protectedText = wikifiedText.replace(/<[^>]+>/g, function(token) {\n\t\t\ttokens.push(token);\n\t\t\treturn \"\\u001D\";\n\t\t});\n\t\tconst replacedText = doFullRegexpReplace(protectedText, fullRegexp, options.template);\n\n\t\treturn replacedText.replace(/\\u001D/g, function() {\n\t\t\treturn tokens.shift();\n\t\t});\n\t}\n\n})(typeof global !== 'undefined' ? global.testRequire : require);\n","type":"application/javascript","module-type":"filteroperator"},"$:/plugins/EvidentlyCube/ExtraOperators/susearch-sort.js":{"title":"$:/plugins/EvidentlyCube/ExtraOperators/susearch-sort.js","text":"/*\\\ntitle: $:/plugins/EvidentlyCube/ExtraOperators/susearch-sort.js\ntype: application/javascript\nmodule-type: filteroperator\n\nSmart sorting of search results\n\n\\*/\n(function(require){\n\n\t/*jslint node: true, browser: true */\n\t/*global $tw: false */\n\t\"use strict\";\n\n\tconst common = require('$:/plugins/EvidentlyCube/ExtraOperators/common.js');\n\n\texports['susearch-sort'] = function(source, operator) {\n\t\tconst query = operator.operand || '';\n\t\tconst suffixes = (operator.suffixes || []);\n\t\tconst optionFlags = suffixes[1] || [];\n\t\tconst options = {\n\t\t\tfield: (suffixes[0] || [])[0] || 'title',\n\t\t\ttextOnly: optionFlags.indexOf('raw-strip') !== -1\n\t\t};\n\n\t\tconst records = [];\n\n\t\tsource(function(tiddler, title) {\n\t\t\trecords.push(tiddler ? tiddler.fields : {title: title});\n\t\t});\n\n\t\treturn susearchSort(records, query, options).map(record => record.title);\n\t};\n\n\tfunction susearchSort(records, query, options) {\n\t\tconst sanitizedQuery = query.replace(/\\s+/g, ' ').trim();\n\t\tconst words = sanitizedQuery.split(' ').filter(word => word);\n\t\tconst simplifiedWords = sanitizedQuery.replace(common.SIMPLIFY_REGEXP, '').split(' ').filter(word => word);\n\n\t\tif (words.length === 0) {\n\t\t\treturn textSort(records, options.field);\n\n\t\t} else if (words.length === 1) {\n\t\t\treturn sortInternal(records, sanitizedQuery, [], [], options);\n\n\t\t} else {\n\t\t\treturn sortInternal(records, sanitizedQuery, words, simplifiedWords, options);\n\t\t}\n\t};\n\n\tfunction textSort(records, sortField) {\n\t\treturn records.concat().sort(function (left, right) {\n\t\t\tif (!left[sortField] && !right[sortField]) {\n\t\t\t\treturn 0;\n\t\t\t} else if (!left[sortField]) {\n\t\t\t\treturn 1;\n\t\t\t} else if (!right[sortField]) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\treturn left[sortField].localeCompare(right[sortField], { numeric: true, sensitivity: \"base\" });\n\t\t});\n\t}\n\n\tfunction sortInternal(records, query, words, simplifiedWords, options) {\n\t\tconst fullQueryRegexps = [query, common.getRegexpsForPhrase(query)];\n\t\tconst wordsRegexps = words.map(word => [word, common.getRegexpsForPhrase(word)]);\n\t\tconst simplifiedWordsRegexps = simplifiedWords.map(word => [word, common.getRegexpsForPhrase(word)]);\n\t\tconst scores = records.map(record => getScore(record, options, fullQueryRegexps, wordsRegexps, simplifiedWordsRegexps));\n\n\t\tscores.sort(recordsSortCallback);\n\n\t\treturn scores.map(x => x[4]);\n\t}\n\n\tfunction recordsSortCallback(left, right) {\n\t\tif (left[0][0] !== right[0][0]) {\n\t\t\treturn right[0][0] - left[0][0];\n\n\t\t} else if (left[0][1] !== right[0][1]) {\n\t\t\treturn right[0][1] - left[0][1];\n\n\t\t} else if (left[0][2] !== right[0][2]) {\n\t\t\treturn left[0][2] - right[0][2];\n\n\t\t} else if (left[1].length !== right[1].length) {\n\t\t\treturn right[1].length - left[1].length;\n\n\t\t} else {\n\t\t\tfor (let i = 0; i < left[1].length; i++) {\n\t\t\t\tif (left[1][i][0] !== right[1][i][0]) {\n\t\t\t\t\treturn right[1][i][0] - left[1][i][0];\n\n\t\t\t\t} else if (left[1][i][1] !== right[1][i][1]) {\n\t\t\t\t\treturn right[1][i][1] - left[1][i][1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (left[2].length !== right[2].length) {\n\t\t\treturn right[2].length - left[2].length;\n\n\t\t} else {\n\t\t\tfor (let i = 0; i < left[2].length; i++) {\n\t\t\t\tif (left[2][i][0] !== right[2][i][0]) {\n\t\t\t\t\treturn right[2][i][0] - left[2][i][0];\n\n\t\t\t\t} else if (left[2][i][1] !== right[2][i][1]) {\n\t\t\t\t\treturn right[2][i][1] - left[2][i][1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0; i < left[3].length; i++) {\n\t\t\tconst score = left[3][i].localeCompare(right[3][i], { numeric: true, sensitivity: \"base\" });\n\t\t\tif (score !== 0) {\n\t\t\t\treturn score;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tfunction getScore(record, options, fullQueryRegexp, wordsRegexps, simplifiedWordsRegexps) {\n\t\tconst rawField = record[options.field] || '';\n\t\tconst field = prepareField(rawField, options);\n\t\tconst simplifiedField = field.replace(common.SIMPLIFY_REGEXP, '');\n\t\tconst fullQueryScore = getRegexpScore(field, fullQueryRegexp[0], fullQueryRegexp[1]);\n\t\tconst wordScores = wordsRegexps\n\t\t\t.map(r => getRegexpScore(field, r[0], r[1]))\n\t\t\t.filter(x => x)\n\t\t\t.sort(wordSortCallback);\n\t\tconst simplifiedWordScores = simplifiedWordsRegexps\n\t\t\t.map(r => getRegexpScore(simplifiedField, r[0], r[1]))\n\t\t\t.filter(x => x)\n\t\t\t.sort(wordSortCallback);\n\n\t\treturn [\n\t\t\tfullQueryScore || [-1, -1, Number.MAX_SAFE_INTEGER], // Full query score match type\n\t\t\twordScores, // Word scores\n\t\t\tsimplifiedWordScores, // Word scores\n\t\t\t[field.toLowerCase(), field, rawField.toLowerCase(), rawField], // Field\n\t\t\trecord // Record\n\t\t];\n\t}\n\n\tfunction wordSortCallback(left, right) {\n\t\tif (left[0] !== right[0]) {\n\t\t\treturn right[0] - left[0];\n\n\t\t} else if (left[1] !== right[1]) {\n\t\t\treturn right[1] - left[1];\n\n\t\t} else {\n\t\t\treturn left[2] - right[2];\n\t\t}\n\t}\n\n\tfunction getRegexpScore(text, query, regexps) {\n\t\tfor (let i = 0; i < regexps.length; i++) {\n\t\t\tconst matches = regexpCount(text, regexps[i]);\n\t\t\tif (matches === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\treturn [\n\t\t\t\tregexps.length - i,\n\t\t\t\tmatches * 10000\n\t\t\t\t+ regexpCount(text, regexps[regexps.length - 1]),\n\t\t\t\ttext.toLowerCase().indexOf(query.toLowerCase())\n\t\t\t];\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tfunction regexpCount(text, regexp) {\n\t\tconst matches = text.match(regexp);\n\n\t\treturn matches ? matches.length : 0;\n\t}\n\n\tfunction prepareField(field, options) {\n\t\tif (options.textOnly) {\n\t\t\treturn common.TEXT_ONLY_REGEXPS.reduce((field, [regexp, replace]) => field.replace(regexp, replace), field).trim();\n\t\t}\n\t\treturn field;\n\t}\n\n})(typeof global !== 'undefined' ? global.testRequire : require);\n","type":"application/javascript","module-type":"filteroperator"},"$:/plugins/EvidentlyCube/ExtraOperators/susearch.js":{"title":"$:/plugins/EvidentlyCube/ExtraOperators/susearch.js","text":"/*\\\ntitle: $:/plugins/EvidentlyCube/ExtraOperators/susearch.js\ntype: application/javascript\nmodule-type: filteroperator\n\nSmart search\n\n\\*/\n(function(require){\n\n\t/*jslint node: true, browser: true */\n\t/*global $tw: false */\n\t\"use strict\";\n\n\tconst common = require('$:/plugins/EvidentlyCube/ExtraOperators/common.js');\n\n\texports.susearch = function(source, operator) {\n\t\tconst query = operator.operand || '';\n\t\tconst suffixes = (operator.suffixes || []);\n\t\tconst optionFlags = suffixes[1] || [];\n\t\tconst options = {\n\t\t\tfield: (suffixes[0] || [])[0] || 'title',\n\t\t\ttextOnly: optionFlags.indexOf('raw-strip') !== -1,\n\t\t\tstrict: optionFlags.indexOf('strict') !== -1,\n\t\t};\n\n\t\tconst sanitizedQuery = query.replace(/\\s+/g, ' ').trim().toLowerCase();\n\t\tconst words = sanitizedQuery.split(' ').filter(word => word);\n\t\tconst simplifiedWords = sanitizedQuery.replace(common.SIMPLIFY_REGEXP, '').split(' ').filter(word => word);\n\n\t\tconst titles = [];\n\n\t\tsource(function(tiddler, title) {\n\t\t\tif (susearch(tiddler ? tiddler.fields : {title: title}, options, sanitizedQuery, words, simplifiedWords)) {\n\t\t\t\ttitles.push(title);\n\t\t\t}\n\t\t});\n\n\t\treturn titles;\n\t};\n\n\tfunction susearch(record, options, sanitizedQuery, words, simplifiedWords) {\n\t\tconst field = prepareField(record[options.field] || '', options).toLowerCase();\n\t\tconst simplifiedField = field.replace(common.SIMPLIFY_REGEXP, '');\n\n\t\tif (field.indexOf(sanitizedQuery) !== -1) {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet wordCount = 0;\n\t\tfor (const word of words) {\n\t\t\tif (field.indexOf(word) !== -1) {\n\t\t\t\twordCount++;\n\n\t\t\t\tif (!options.strict || wordCount === words.length) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t} else if (options.strict) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twordCount = 0;\n\t\tfor (const word of simplifiedWords) {\n\t\t\tif (simplifiedField.indexOf(word) !== -1) {\n\t\t\t\twordCount++;\n\n\t\t\t\tif (!options.strict || wordCount === words.length) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t} else if (options.strict) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tfunction prepareField(field, options) {\n\t\tif (options.textOnly) {\n\t\t\treturn common.TEXT_ONLY_REGEXPS.reduce((field, [regexp, replace]) => field.replace(regexp, replace), field);\n\t\t}\n\t\treturn field;\n\t}\n\n})(typeof global !== 'undefined' ? global.testRequire : require);\n","type":"application/javascript","module-type":"filteroperator"}}}