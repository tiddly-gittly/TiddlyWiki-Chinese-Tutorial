{"tiddlers":{"$:/plugins/cdaven/markdown-export/details":{"title":"$:/plugins/cdaven/markdown-export/details","created":"20221113100340267","text":"!! Markdown Flavour\n\nThere are quite a few different Markdown specifications, and I have settled on [[Pandoc Markdown|https://pandoc.org/MANUAL.html#pandocs-markdown]], for two reasons:\n\n# Pandoc Markdown is quite capable, with a lot of extensions. All of these extensions will not work in every Markdown renderer, but most will.\n# [[Pandoc|https://pandoc.org]] itself is a great way to convert from (Pandoc) Markdown to other document formats, such as Word or PDF.\n\n!!! Further conversion with Pandoc\n\nYou can convert a Markdown file to Word with this simple Pandoc command:\n\n```\npandoc -o output.docx input.md\n```\n\nSimply change \".docx\" to \".html\" or \".pdf\" to convert to other formats, or use [[the --to switch|https://pandoc.org/MANUAL.html#option--to]].\n\nYou can also convert this Pandoc Markdown file to ~CommonMark or ~GitHub-Flavored Markdown like this:\n\n```\npandoc -o common.md --to commonmark input.md\npandoc -o github.md --to gfm input.md\n```\n\n!! Some caveats\n\nSince ~TiddlyWiki is very expressive -- and has a multitude of plugins -- export plugins such as this probably cannot support all possible variations.\n\nConverting to Markdown requires a bunch of compromises, and will therefore be \"opinionated\". This is how //I// want my Markdown to look.\n\n!! Encoding\n\nThe Markdown file will be encoded with UTF-8 and Linux/Mac newlines (still works on Windows!). This should work on most platforms and with most third party applications.\n\n!! System Requirements\n\nThe plugin uses relatively modern Javascript (\"ES2015\") that doesn't work in Internet Explorer. Most modern browsers //should// work."},"$:/plugins/cdaven/markdown-export/exportNote":{"title":"$:/plugins/cdaven/markdown-export/exportNote","created":"20220602113244086","description":"A note that will be added as a comment to exported Markdown files","modified":"20220602113609303","tags":"","text":"Exported from TiddlyWiki at <<now>>"},"$:/plugins/cdaven/markdown-export/license":{"title":"$:/plugins/cdaven/markdown-export/license","created":"20220513163358248","modified":"20220513163418690","tags":"","text":"Copyright 2022 Christian Davén\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."},"$:/plugins/cdaven/markdown-export/markdown-export.js":{"title":"$:/plugins/cdaven/markdown-export/markdown-export.js","text":"/*\\\r\ntitle: $:/plugins/cdaven/markdown-export/markdown-export.js\r\ntype: application/javascript\r\nmodule-type: macro\r\n\\*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.exportedForTesting = exports.run = exports.params = exports.name = void 0;\r\nconst render_js_1 = require(\"./render.js\");\r\nexports.name = \"markdown-export\";\r\nexports.params = [\r\n    {\r\n        name: \"filter\",\r\n        default: \"\"\r\n    },\r\n    {\r\n        name: \"note\",\r\n        default: \"\"\r\n    },\r\n    {\r\n        name: \"version\",\r\n        default: \"\"\r\n    },\r\n];\r\n/** Insert note as comment right after front matter */\r\nfunction insertNote(markdownTiddler, note) {\r\n    return markdownTiddler.replace(/(---\\n+)(#)/, `$1<!-- ${note.replace(/\\$/g, \"$$$$\")} -->\\n\\n$2`);\r\n}\r\n/** The macro entrypoint */\r\nfunction run(filter = \"\", note = \"\", version = \"\") {\r\n    console.log(`Running Markdown Export ${version} with filter ${filter}`);\r\n    if (!filter) {\r\n        console.warn(\"No filter specified, exiting\");\r\n        return \"\";\r\n    }\r\n    const twRenderer = new render_js_1.TiddlyWikiRenderer($tw);\r\n    const renderer = new render_js_1.MarkdownRenderer(twRenderer);\r\n    // Expand macros in note\r\n    note = twRenderer.wikifyText(note);\r\n    let markdownTiddlers = [];\r\n    for (const title of $tw.wiki.filterTiddlers(filter)) {\r\n        console.log(`Rendering [[${title}]] to Markdown`);\r\n        let markdownTiddler = null;\r\n        try {\r\n            markdownTiddler = renderer.renderTiddler(title);\r\n        }\r\n        catch (err) {\r\n            console.error(err);\r\n        }\r\n        if (markdownTiddler) {\r\n            if (note) {\r\n                markdownTiddler = insertNote(markdownTiddler, note);\r\n            }\r\n            markdownTiddlers.push(markdownTiddler.trim());\r\n        }\r\n    }\r\n    // LaTeX page break, recognized by Pandoc\r\n    const pageBreak = \"\\n\\n\\\\newpage\\n\\n\";\r\n    return markdownTiddlers.join(pageBreak);\r\n}\r\nexports.run = run;\r\n;\r\n/** Make stuff available for unit testing */\r\nexports.exportedForTesting = {\r\n    insertNote\r\n};\r\n// export {};\r\n","type":"application/javascript","module-type":"macro"},"$:/plugins/cdaven/markdown-export/md-tiddler.js":{"title":"$:/plugins/cdaven/markdown-export/md-tiddler.js","text":"/*\\\r\ntitle: $:/plugins/cdaven/markdown-export/md-tiddler.js\r\ntype: application/javascript\r\nmodule-type: macro\r\n\r\nMacro to output a single tiddler to Markdown, e.g. for use with a template, possibly from the command line.\r\n\\*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.run = exports.params = exports.name = void 0;\r\nconst render_js_1 = require(\"./render.js\");\r\nexports.name = \"mdtiddler\";\r\nexports.params = [\r\n    {\r\n        name: \"title\",\r\n        default: \"\"\r\n    },\r\n];\r\n/** The macro entrypoint */\r\nfunction run(title = \"\") {\r\n    title = title || this.getVariable(\"currentTiddler\");\r\n    if (!title) {\r\n        console.warn(\"No title specified, exiting\");\r\n        return \"\";\r\n    }\r\n    if (title === \"$:/plugins/cdaven/markdown-export/md-tiddler\") {\r\n        // TODO: This avoids a Javascript error, but there should be a better solution\r\n        console.warn(\"Shouldn't render itself...?\");\r\n        return \"\";\r\n    }\r\n    const twRenderer = new render_js_1.TiddlyWikiRenderer($tw);\r\n    const renderer = new render_js_1.MarkdownRenderer(twRenderer);\r\n    return renderer.renderTiddler(title) || \"\";\r\n}\r\nexports.run = run;\r\n;\r\n","type":"application/javascript","module-type":"macro"},"$:/plugins/cdaven/markdown-export/md-tiddler":{"title":"$:/plugins/cdaven/markdown-export/md-tiddler","created":"20220606063844580","text":"<!--\n\nThis template is used for saving tiddlers as Markdown\n\n--><$text text=<<mdtiddler>>/>"},"$:/plugins/cdaven/markdown-export/MenuItem":{"title":"$:/plugins/cdaven/markdown-export/MenuItem","created":"20220421104331124","description":"Markdown","extension":".md","tags":"$:/tags/Exporter","text":"<$macrocall $name=\"markdown-export\" filter=<<exportFilter>> note={{$:/plugins/cdaven/markdown-export/exportNote}} version={{$:/plugins/cdaven/markdown-export!!version}} $output=\"text/raw\"/>\n"},"$:/plugins/cdaven/markdown-export/readme":{"title":"$:/plugins/cdaven/markdown-export/readme","created":"20220513163340267","text":"This is a plugin for ~TiddlyWiki that lets you export tiddlers to Markdown, either in the web browser or on the command line.\n\n!! In the browser (or similar graphical user interfaces)\n\nClick the \"Export tiddler\" button or menu item on the tiddler to export, and select \"Markdown\". A Markdown file will be generated and downloaded.\n\nYou can also use the \"Export tiddlers\" button from [[$:/AdvancedSearch]] in the \"Filter\" tab, to export many tiddlers to one big Markdown file.\n\n!! On the command line\n\nUse the [[TiddlyWiki command installable via npm|https://www.npmjs.com/package/tiddlywiki]] and type something like this:\n\n```sh\ntiddlywiki <folder> --render <tiddler> '[encodeuricomponent[]addsuffix[.md]]' 'text/plain' '$:/plugins/cdaven/markdown-export/md-tiddler'\n```\n\n!! Homepage\n\nThis plugin's homepage is at https://cdaven.github.io/tiddlywiki/\n\n!! Source Code\n\nThe source code is available at https://github.com/cdaven/tiddlywiki-stuff/tree/main/markdown-export -- this is where you can report issues or request features."},"$:/plugins/cdaven/markdown-export/render-helpers.js":{"title":"$:/plugins/cdaven/markdown-export/render-helpers.js","text":"/*\\\r\ntitle: $:/plugins/cdaven/markdown-export/render-helpers.js\r\ntype: application/javascript\r\nmodule-type: library\r\n\\*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.isDomNode = exports.isTextNode = exports.trimEnd = exports.btoa = exports.Node = void 0;\r\n/* Polyfill browser stuff when run from Node.js */\r\nexports.Node = globalThis.Node || {\r\n    ELEMENT_NODE: 1,\r\n    TEXT_NODE: 3,\r\n};\r\n/* Polyfill browser stuff when run from Node.js */\r\nexports.btoa = globalThis.btoa || function (data) {\r\n    const ascii = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\r\n    let len = data.length - 1, i = -1, b64 = '';\r\n    while (i < len) {\r\n        const code = data.charCodeAt(++i) << 16 | data.charCodeAt(++i) << 8 | data.charCodeAt(++i);\r\n        b64 += ascii[(code >>> 18) & 63] + ascii[(code >>> 12) & 63] + ascii[(code >>> 6) & 63] + ascii[code & 63];\r\n    }\r\n    const pads = data.length % 3;\r\n    if (pads > 0) {\r\n        b64 = b64.slice(0, pads - 3);\r\n        while (b64.length % 4 !== 0) {\r\n            b64 += '=';\r\n        }\r\n    }\r\n    return b64;\r\n};\r\nfunction trimEnd(s) {\r\n    return s.replace(/\\s+$/, \"\");\r\n}\r\nexports.trimEnd = trimEnd;\r\nfunction isTextNode(node) {\r\n    if (node.nodeType === exports.Node.TEXT_NODE)\r\n        return true;\r\n    else if (typeof node.nodeType === \"undefined\")\r\n        return node.hasOwnProperty(\"textContent\");\r\n    else\r\n        return false;\r\n}\r\nexports.isTextNode = isTextNode;\r\nfunction isDomNode(node) {\r\n    if (node.nodeType === exports.Node.ELEMENT_NODE)\r\n        return true;\r\n    else if (typeof node.nodeType === \"undefined\")\r\n        return node.hasOwnProperty(\"children\");\r\n    else\r\n        return false;\r\n}\r\nexports.isDomNode = isDomNode;\r\n","type":"application/javascript","module-type":"library"},"$:/plugins/cdaven/markdown-export/render-rules.js":{"title":"$:/plugins/cdaven/markdown-export/render-rules.js","text":"/*\\\r\ntitle: $:/plugins/cdaven/markdown-export/render-rules.js\r\ntype: application/javascript\r\nmodule-type: library\r\n\\*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.getRules = void 0;\r\nconst render_helpers_1 = require(\"./render-helpers\");\r\n/** Get rules for rendering a TiddlyWiki widget tree consisting of HTML-ish elements/nodes */\r\nfunction getRules(renderer) {\r\n    let rules = {\r\n        // The <meta> tag contains the document's title and other attributes\r\n        \"meta\": (node) => {\r\n            const fields = node.attributes;\r\n            let frontMatter = [];\r\n            if (fields.title) {\r\n                frontMatter.push(`title: '${fields.title}'`);\r\n            }\r\n            if (fields.author) {\r\n                frontMatter.push(`author: '${fields.author}'`);\r\n            }\r\n            if (fields.modified instanceof Date) {\r\n                frontMatter.push(`date: '${fields.modified.toISOString()}'`);\r\n            }\r\n            if (fields.description) {\r\n                frontMatter.push(`abstract: '${fields.description}'`);\r\n            }\r\n            if (fields.tags && fields.tags.length > 0) {\r\n                // Enclose tags with single quotes and escape single quotes inside the tags\r\n                const tags = fields.tags.map((t) => `'${t.replace(\"'\", \"\\\\'\")}'`);\r\n                frontMatter.push(`tags: [${tags.join(', ')}]`);\r\n            }\r\n            for (const field in fields) {\r\n                if ([\"text\", \"title\", \"author\", \"modified\", \"description\", \"tags\"].indexOf(field) !== -1)\r\n                    // Ignore full text and the fields already taken care of\r\n                    continue;\r\n                // Clean up field name\r\n                const fieldName = field.replace(/\\s+/g, \"-\").replace(\":\", \"\");\r\n                // Clean up field value\r\n                let fieldValue = fields[field];\r\n                if (fieldValue instanceof Date) {\r\n                    fieldValue = \"'\" + fieldValue.toISOString() + \"'\";\r\n                }\r\n                else if (typeof fieldValue !== \"number\") {\r\n                    // Remove newlines and escape single quotes\r\n                    fieldValue = \"'\" + fieldValue.toString().replace(/[\\r\\n]+/g, \"\").replace(\"'\", \"\\\\'\") + \"'\";\r\n                }\r\n                frontMatter.push(`${fieldName}: ${fieldValue}`);\r\n            }\r\n            return `---\\n${frontMatter.join(\"\\n\")}\\n---\\n\\n# ${fields.title}\\n\\n`;\r\n        },\r\n        \"p\": (node, im) => {\r\n            var _a;\r\n            if (((_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.tag) === \"li\") {\r\n                const newlines = renderer.isLastChild(node)\r\n                    ? \"\\n\" // End with one newline for the last child\r\n                    : \"\\n\\n\"; // End with two newlines between paragraphs\r\n                if (node.parentNode.children[0] == node) {\r\n                    // The first <p> inside a <li> is rendered as inline text\r\n                    return `${im.trim()}${newlines}`;\r\n                }\r\n                else {\r\n                    // Subsequent <p> inside a <li> is rendered with indentation\r\n                    return `    ${im.trim()}${newlines}`;\r\n                }\r\n            }\r\n            else {\r\n                // Add newlines after paragraphs\r\n                return `${im.trim()}\\n\\n`;\r\n            }\r\n        },\r\n        \"em\": (_, im) => `*${im}*`,\r\n        \"strong\": (_, im) => `**${im}**`,\r\n        \"u\": (_, im) => `<u>${im}</u>`,\r\n        \"strike\": (_, im) => `~~${im}~~`,\r\n        // Force line-break\r\n        \"br\": (node) => {\r\n            const nextNode = renderer.getNextNode(node);\r\n            if (nextNode == null || ((0, render_helpers_1.isTextNode)(nextNode) && nextNode.textContent === \"\\n\")) {\r\n                // If the next line is blank, shouldn't end with a \\\r\n                return \"\\n\";\r\n            }\r\n            else {\r\n                return \"\\\\\\n\";\r\n            }\r\n        },\r\n        \"hr\": () => `---\\n\\n`,\r\n        \"label\": (_, im) => im,\r\n        // Pandoc 3.0 supports highlighted text using ==, if you specify --from markdown+mark\r\n        \"mark\": (_, im) => `==${im}==`,\r\n        \"span\": (node, im) => {\r\n            const katexStart = '<annotation encoding=\"application/x-tex\">';\r\n            if (node.rawHTML && node.rawHTML.indexOf(katexStart) !== -1) {\r\n                let mathEq = node.rawHTML.substring(node.rawHTML.indexOf(katexStart) + katexStart.length);\r\n                mathEq = mathEq.substring(0, mathEq.indexOf('</annotation>'));\r\n                if (mathEq.startsWith(\"\\n\") && mathEq.endsWith(\"\\n\")) {\r\n                    // As a block equation\r\n                    return `$$${mathEq}$$\\n\\n`;\r\n                }\r\n                else {\r\n                    // As an inline equation\r\n                    return `$${mathEq}$`;\r\n                }\r\n            }\r\n            else {\r\n                return im;\r\n            }\r\n        },\r\n        \"sub\": (_, im) => `~${im.replace(/ /g, \"\\\\ \")}~`,\r\n        \"sup\": (_, im) => `^${im.replace(/ /g, \"\\\\ \")}^`,\r\n        \"h1\": (_, im) => `# ${im}\\n\\n`,\r\n        \"h2\": (_, im) => `## ${im}\\n\\n`,\r\n        \"h3\": (_, im) => `### ${im}\\n\\n`,\r\n        \"h4\": (_, im) => `#### ${im}\\n\\n`,\r\n        // Definition lists\r\n        \"dl\": (_, im) => `${im.trim()}\\n\\n`,\r\n        \"dt\": (_, im) => `${im}\\n`,\r\n        \"dd\": (_, im) => ` ~ ${im}\\n\\n`,\r\n        // Code blocks\r\n        \"pre\": (node, im) => {\r\n            if (node.children.every(child => (0, render_helpers_1.isDomNode)(child) && child.tag === \"code\")) {\r\n                // <pre> with nested <code> elements, just pass through\r\n                return im;\r\n            }\r\n            else {\r\n                // <pre> without nested <code>\r\n                return `\\`\\`\\`\\n${im.trim()}\\n\\`\\`\\`\\n\\n`;\r\n            }\r\n        },\r\n        \"code\": (node, im) => {\r\n            var _a, _b, _c;\r\n            if (((_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.tag) === \"pre\") {\r\n                // <code> nested inside <pre>\r\n                // The Highlight plugin puts the language in the \"class\" attribute\r\n                let classRx = (_c = (_b = node.attributes) === null || _b === void 0 ? void 0 : _b.class) === null || _c === void 0 ? void 0 : _c.match(/^(.+) hljs$/);\r\n                if (classRx) {\r\n                    const lang = classRx[1];\r\n                    return `\\`\\`\\`${lang}\\n${im.trim()}\\n\\`\\`\\`\\n\\n`;\r\n                }\r\n                else {\r\n                    return `\\`\\`\\`\\n${im.trim()}\\n\\`\\`\\`\\n\\n`;\r\n                }\r\n            }\r\n            else {\r\n                // As inline code\r\n                return `\\`${im}\\``;\r\n            }\r\n        },\r\n        \"blockquote\": (node, im) => {\r\n            var _a;\r\n            let indentation = \"\";\r\n            if (((_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.tag) === \"li\") {\r\n                indentation = \"    \";\r\n            }\r\n            // Insert \"> \" at the beginning of each line\r\n            const prefix = `${indentation}> `;\r\n            return `${prefix}${im.trim().replace(/\\n/g, `\\n${prefix}`)}\\n\\n`;\r\n        },\r\n        \"cite\": (_, im) => {\r\n            return `<cite>${im}</cite>`;\r\n        },\r\n        // Lists\r\n        \"ul\": (node, im) => {\r\n            var _a;\r\n            if (((_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.tag) === \"li\") {\r\n                // Nested list, should not end with double newlines\r\n                return `\\n${im}`;\r\n            }\r\n            else {\r\n                return `${im.trim()}\\n\\n`;\r\n            }\r\n        },\r\n        \"li\": (node, im) => {\r\n            let curNode = node.parentNode;\r\n            if (curNode == null) {\r\n                console.error(\"Found <li> without parent\");\r\n                return null;\r\n            }\r\n            const listType = curNode.tag === \"ul\" ? \"*\" : \"1.\";\r\n            const listTags = [\"ul\", \"ol\", \"li\"];\r\n            let depth = -1;\r\n            // Traverse up the path to count nesting levels\r\n            while (curNode && listTags.indexOf(curNode.tag) !== -1) {\r\n                if (curNode.tag !== \"li\") {\r\n                    depth++;\r\n                }\r\n                curNode = curNode.parentNode;\r\n            }\r\n            const indent = \"    \".repeat(depth);\r\n            return `${indent}${listType} ${im.trim()}\\n`;\r\n        },\r\n        \"input\": (node) => {\r\n            var _a, _b;\r\n            if (((_a = node.attributes) === null || _a === void 0 ? void 0 : _a.type) === \"checkbox\") {\r\n                if ((_b = node.attributes) === null || _b === void 0 ? void 0 : _b.checked) {\r\n                    return \"[x]\";\r\n                }\r\n                else {\r\n                    return \"[ ]\";\r\n                }\r\n            }\r\n            else {\r\n                console.warn(\"Unsupported input node type\", node);\r\n                return null;\r\n            }\r\n        },\r\n        \"a\": (node, im) => {\r\n            var _a;\r\n            const href = (_a = node.attributes) === null || _a === void 0 ? void 0 : _a.href;\r\n            if (href == null || (href === null || href === void 0 ? void 0 : href.startsWith(\"#\"))) {\r\n                // Render internal links as plain text, since the links probably lose all meaning outside the TiddlyWiki.\r\n                return im;\r\n            }\r\n            else if (im && im != href) {\r\n                return `[${im}](${href})`;\r\n            }\r\n            else {\r\n                return `<${href}>`;\r\n            }\r\n        },\r\n        \"img\": (node) => {\r\n            var _a, _b;\r\n            let caption = ((_a = node.attributes) === null || _a === void 0 ? void 0 : _a.title) || \"\";\r\n            let src = ((_b = node.attributes) === null || _b === void 0 ? void 0 : _b.src) || \"\";\r\n            const svgPrefix = \"data:image/svg+xml,\";\r\n            if (src.startsWith(svgPrefix)) {\r\n                // SVGs should also be Base64-encoded for compatibility\r\n                src = svgPrefix.replace(\"svg+xml,\", \"svg+xml;base64,\") +\r\n                    (0, render_helpers_1.btoa)(decodeURIComponent(src.substring(svgPrefix.length)));\r\n            }\r\n            return `![${caption}](${src})`;\r\n        },\r\n        \"i\": (node, im) => {\r\n            var _a;\r\n            if ((_a = node.attributes) === null || _a === void 0 ? void 0 : _a.class) {\r\n                const classes = node.attributes.class.split(\" \");\r\n                if (im.trim().length === 0 && classes.some(c => c.startsWith(\"fa-\"))) {\r\n                    // Lazily render all FontAwesome icons as a replacement character\r\n                    return \"�\";\r\n                }\r\n            }\r\n            return null;\r\n        },\r\n        // Tables\r\n        \"table\": (node) => {\r\n            let tbody = null;\r\n            for (const child of node.children) {\r\n                if ((0, render_helpers_1.isDomNode)(child) && child.tag === \"tbody\") {\r\n                    tbody = child;\r\n                    break;\r\n                }\r\n            }\r\n            if (tbody == null) {\r\n                return null;\r\n            }\r\n            const justifyLeft = (s, w) => {\r\n                const sLen = (s === null || s === void 0 ? void 0 : s.length) || 0;\r\n                return s + ' '.repeat(w - sLen);\r\n            };\r\n            const justifyRight = (s, w) => {\r\n                const sLen = (s === null || s === void 0 ? void 0 : s.length) || 0;\r\n                return ' '.repeat(w - sLen) + s;\r\n            };\r\n            const center = (s, w) => {\r\n                const sLen = (s === null || s === void 0 ? void 0 : s.length) || 0;\r\n                const spacesLeft = Math.ceil((w - sLen) / 2);\r\n                const spacesRight = w - sLen - spacesLeft;\r\n                return ' '.repeat(spacesLeft) + s + ' '.repeat(spacesRight);\r\n            };\r\n            let grid = [];\r\n            for (const row of tbody.children) {\r\n                if ((0, render_helpers_1.isDomNode)(row) && row.tag === \"tr\") {\r\n                    let cellsInCurrentRow = [];\r\n                    for (const cell of row.children) {\r\n                        if ((0, render_helpers_1.isDomNode)(cell)) {\r\n                            cellsInCurrentRow.push({\r\n                                innerMarkup: renderer.renderNode(cell),\r\n                                header: cell.tag === \"th\",\r\n                                align: cell.attributes.align,\r\n                            });\r\n                        }\r\n                    }\r\n                    grid.push(cellsInCurrentRow);\r\n                }\r\n            }\r\n            let columnWidths = [];\r\n            for (let i = 0; i < grid[0].length; i++) {\r\n                // Check max length of each column's inner markup\r\n                columnWidths.push(Math.max(...grid.map(row => { var _a; return ((_a = row[i].innerMarkup) === null || _a === void 0 ? void 0 : _a.length) || 0; })));\r\n            }\r\n            let tableMarkup = [];\r\n            let isFirstRow = true;\r\n            for (const row of grid) {\r\n                let rowMarkup = [];\r\n                for (const column in row) {\r\n                    const cell = row[column];\r\n                    const innerMarkup = cell.innerMarkup;\r\n                    const columnWidth = columnWidths[column];\r\n                    if (cell.align === \"center\") {\r\n                        rowMarkup.push(center(innerMarkup, columnWidth));\r\n                    }\r\n                    else if (cell.align === \"right\") {\r\n                        rowMarkup.push(justifyRight(innerMarkup, columnWidth));\r\n                    }\r\n                    else {\r\n                        rowMarkup.push(justifyLeft(innerMarkup, columnWidth));\r\n                    }\r\n                }\r\n                tableMarkup.push(\"| \" + rowMarkup.join(\" | \") + \" |\");\r\n                if (isFirstRow) {\r\n                    // Markdown requires the first row to be a header row\r\n                    let rowMarkup = [];\r\n                    for (const column in row) {\r\n                        const columnWidth = columnWidths[column];\r\n                        rowMarkup.push(\"-\".repeat(columnWidth));\r\n                    }\r\n                    tableMarkup.push(\"|-\" + rowMarkup.join(\"-|-\") + \"-|\");\r\n                    isFirstRow = false;\r\n                }\r\n            }\r\n            return tableMarkup.join(\"\\n\") + \"\\n\\n\";\r\n        },\r\n        // The <tr> tag is handled by the <table> rule\r\n        \"tr\": () => null,\r\n        \"td\": (_, im) => im,\r\n        \"th\": (_, im) => im,\r\n        // Generic block element rule\r\n        \"block\": (node, im) => {\r\n            if (im.trim().length > 0) {\r\n                return `<${node.tag}>${im.trim()}</${node.tag}>\\n`;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        },\r\n        // Wildcard rule, catching all other inline elements\r\n        \"*\": (node, im) => {\r\n            if (im.trim().length > 0) {\r\n                return `<${node.tag}>${im.trim()}</${node.tag}>`;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        },\r\n    };\r\n    // Inherit identical rules\r\n    rules[\"div\"] = rules[\"p\"];\r\n    rules[\"ol\"] = rules[\"ul\"];\r\n    // Generic block elements\r\n    rules[\"address\"] = rules[\"block\"];\r\n    rules[\"article\"] = rules[\"block\"];\r\n    rules[\"aside\"] = rules[\"block\"];\r\n    rules[\"details\"] = rules[\"block\"];\r\n    rules[\"dialog\"] = rules[\"block\"];\r\n    rules[\"fieldset\"] = rules[\"block\"];\r\n    rules[\"figcaption\"] = rules[\"block\"];\r\n    rules[\"figure\"] = rules[\"block\"];\r\n    rules[\"footer\"] = rules[\"block\"];\r\n    rules[\"form\"] = rules[\"block\"];\r\n    rules[\"header\"] = rules[\"block\"];\r\n    rules[\"hgroup\"] = rules[\"block\"];\r\n    rules[\"main\"] = rules[\"block\"];\r\n    rules[\"nav\"] = rules[\"block\"];\r\n    rules[\"section\"] = rules[\"block\"];\r\n    return rules;\r\n}\r\nexports.getRules = getRules;\r\n","type":"application/javascript","module-type":"library"},"$:/plugins/cdaven/markdown-export/render.js":{"title":"$:/plugins/cdaven/markdown-export/render.js","text":"/*\\\r\ntitle: $:/plugins/cdaven/markdown-export/render.js\r\ntype: application/javascript\r\nmodule-type: library\r\n\\*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.MarkdownRenderer = exports.TiddlyWikiRenderer = void 0;\r\nconst render_helpers_js_1 = require(\"./render-helpers.js\");\r\nconst render_rules_js_1 = require(\"./render-rules.js\");\r\n// type NodeRenderer = (node: TW_Element, innerMarkup: string) => string | null;\r\n// type RulesRecord = Record<string, NodeRenderer>;\r\n// TODO: Look at/think about https://tiddlywiki.com/static/Creating%2520a%2520custom%2520export%2520format.html\r\nclass TiddlyWikiRenderer {\r\n    constructor(tw) {\r\n        this.tw = tw;\r\n        // Imports built-in macros and custom macros in the tiddler, including the $:/tags/Macro/View tag\r\n        const macroImport = \"[[$:/core/ui/PageMacros]] [all[shadows+tiddlers]tag[$:/tags/Macro]!has[draft.of]] [all[shadows+tiddlers]tag[$:/tags/Macro/View]!has[draft.of]]\";\r\n        this.widgetOptions = {\r\n            document: $tw.fakeDocument,\r\n            mode: \"block\",\r\n            importVariables: macroImport,\r\n            recursionMarker: \"yes\",\r\n            variables: {\r\n                currentTiddler: null\r\n            }\r\n        };\r\n    }\r\n    /** Let TiddlyWiki parse the tiddler text and build a widget tree */\r\n    renderWidgetTree(title) {\r\n        this.widgetOptions.variables.currentTiddler = title;\r\n        const widgetNode = this.tw.wiki.makeTranscludeWidget(title, this.widgetOptions);\r\n        const container = this.tw.fakeDocument.createElement(\"div\");\r\n        widgetNode.render(container, null);\r\n        // Get the first-level nodes in the tree\r\n        return container.children[0].children;\r\n    }\r\n    /** \"Wikify\" a WikiText string */\r\n    wikifyText(text) {\r\n        return this.tw.wiki.renderText(\"text/plain\", \"text/vnd.tiddlywiki\", text);\r\n    }\r\n    /** Get tiddler fields */\r\n    getFields(title) {\r\n        const tiddler = this.tw.wiki.getTiddler(title);\r\n        if (tiddler == null) {\r\n            console.warn(\"Found no such tiddler\", title);\r\n            return null;\r\n        }\r\n        // Clone tiddler fields\r\n        return Object.assign({}, tiddler.fields);\r\n    }\r\n}\r\nexports.TiddlyWikiRenderer = TiddlyWikiRenderer;\r\nclass MarkdownRenderer {\r\n    constructor(tw) {\r\n        this.tw = tw;\r\n        this.rules = (0, render_rules_js_1.getRules)(this);\r\n    }\r\n    renderTiddler(title) {\r\n        if (this.rules == null) {\r\n            console.warn(\"Cannot render tiddler without rules\");\r\n            return null;\r\n        }\r\n        const nodes = this.tw.renderWidgetTree(title);\r\n        this.tiddlerFields = this.tw.getFields(title);\r\n        if (this.tiddlerFields == null) {\r\n            console.warn(`Tiddler [[${title}]] doesn't seem to exist`);\r\n            return null;\r\n        }\r\n        let renderedNodes = \"\";\r\n        for (const node of nodes) {\r\n            const nodeMarkup = this.renderNode(node);\r\n            if (nodeMarkup != null) {\r\n                renderedNodes += nodeMarkup;\r\n            }\r\n        }\r\n        // Prepend meta node last, in case attributes have changed during rendering\r\n        const metaNode = {\r\n            tag: \"meta\",\r\n            nodeType: render_helpers_js_1.Node.ELEMENT_NODE,\r\n            attributes: this.tiddlerFields,\r\n            children: []\r\n        };\r\n        let markup = this.renderNode(metaNode) + renderedNodes;\r\n        return markup.replace(/\\n\\n\\n+/g, \"\\n\\n\").trim() + \"\\n\";\r\n    }\r\n    /** Get raw text from node */\r\n    getNodeText(node) {\r\n        if ((0, render_helpers_js_1.isTextNode)(node)) {\r\n            return node.textContent || \"\";\r\n        }\r\n        else if ((0, render_helpers_js_1.isDomNode)(node)) {\r\n            return node.children.map(child => this.getNodeText(child)).join(\" \");\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /** Render specified node to Markdown */\r\n    renderNode(node) {\r\n        if ((0, render_helpers_js_1.isTextNode)(node)) {\r\n            return node.textContent || \"\";\r\n        }\r\n        else if ((0, render_helpers_js_1.isDomNode)(node)) {\r\n            // Render markup from children depth-first\r\n            const innerMarkup = node.children.map(child => this.renderNode(child)).join(\"\");\r\n            return this.executeRule(node, innerMarkup);\r\n        }\r\n        else {\r\n            console.error(\"Unknown type of node\", node);\r\n            throw new Error(\"Unknown type of node\");\r\n        }\r\n    }\r\n    /** Get next sibling of specified node */\r\n    getNextNode(node) {\r\n        if (node.parentNode == null) {\r\n            return null;\r\n        }\r\n        let isNext = false;\r\n        for (const n of node.parentNode.children) {\r\n            if (isNext) {\r\n                return n;\r\n            }\r\n            else if (n === node) {\r\n                isNext = true;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    isFirstChild(node) {\r\n        if (node.parentNode == null) {\r\n            // Define all root elements as the first and last children\r\n            return true;\r\n        }\r\n        return node == node.parentNode.children[0];\r\n    }\r\n    isLastChild(node) {\r\n        if (node.parentNode == null) {\r\n            // Define all root elements as the first and last children\r\n            return true;\r\n        }\r\n        return node == node.parentNode.children[node.parentNode.children.length - 1];\r\n    }\r\n    executeRule(node, innerMarkup) {\r\n        if (node.tag in this.rules) {\r\n            return this.rules[node.tag](node, innerMarkup);\r\n        }\r\n        else {\r\n            // Use wildcard rule when tag doesn't have its own rule\r\n            return this.rules[\"*\"](node, innerMarkup);\r\n        }\r\n    }\r\n}\r\nexports.MarkdownRenderer = MarkdownRenderer;\r\n","type":"application/javascript","module-type":"library"}}}